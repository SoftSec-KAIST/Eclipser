--- qemu-2.10.0-branch/linux-user/syscall.c.orig	2020-10-03 21:06:01.965430923 -0700
+++ qemu-2.10.0-branch/linux-user/syscall.c	2020-10-03 21:05:57.281403019 -0700
@@ -116,6 +116,10 @@
 
 #include "qemu.h"
 
+extern void chatkey_exit(void);
+extern void chatkey_close_fp(void);
+extern unsigned int afl_forksrv_pid;
+
 #ifndef CLONE_IO
 #define CLONE_IO                0x80000000      /* Clone io context */
 #endif
@@ -6354,6 +6358,7 @@
         ret = fork();
         if (ret == 0) {
             /* Child Process.  */
+            chatkey_close_fp();
             cpu_clone_regs(env, newsp);
             fork_end(1);
             /* There is a race condition here.  The parent process could
@@ -7764,6 +7769,7 @@
 #ifdef TARGET_GPROF
         _mcleanup();
 #endif
+        chatkey_exit();
         gdb_exit(cpu_env, arg1);
         _exit(arg1);
         ret = 0; /* avoid warning */
@@ -9820,6 +9826,7 @@
 #ifdef TARGET_GPROF
         _mcleanup();
 #endif
+        chatkey_exit();
         gdb_exit(cpu_env, arg1);
         ret = get_errno(exit_group(arg1));
         break;
@@ -11688,8 +11695,20 @@
         break;
 
     case TARGET_NR_tgkill:
-        ret = get_errno(safe_tgkill((int)arg1, (int)arg2,
-                        target_to_host_signal(arg3)));
+        {
+          int pid  = (int)arg1,
+              tgid = (int)arg2,
+              sig  = (int)arg3;
+
+          /* Thought to be a workaround for -lpthread to make abort() work
+           * properly, without killing the forkserver due to a prematurely
+           * cached PID. */
+
+          if (afl_forksrv_pid && afl_forksrv_pid == pid && sig == SIGABRT)
+              pid = tgid = getpid();
+
+          ret = get_errno(safe_tgkill(pid, tgid, target_to_host_signal(sig)));
+        }
         break;
 
 #ifdef TARGET_NR_set_robust_list
